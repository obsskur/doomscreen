<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #111;
    overflow: hidden;
    user-select: none;
    cursor: pointer;
    position: relative;
  }
  #text {
    position: absolute;
    color: #eee;
    font-family: system-ui, sans-serif;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    pointer-events: none;
  }
  .square {
    position: absolute;
    width: 200px;
    height: 200px;
    transition: background 0.2s;
  }
</style>
</head>
<body>

<div id="text">点击此处测试此程序!</div>

<script>
const squareSize = 200;
let squares = [];
let flashColor = true;
const originalBG = "#111";
let animationId = null;
let flashInterval = null;
let duplicationInterval = null;
let squaresStarted = false;

// Square class
class Square {
  constructor(x = Math.random() * (window.innerWidth - squareSize),
              y = Math.random() * (window.innerHeight - squareSize)) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 6;
    this.vy = (Math.random() - 0.5) * 6;
    this.div = document.createElement('div');
    this.div.className = 'square';
    this.div.style.background = flashColor ? '#fff' : '#000';
    document.body.appendChild(this.div);
    this.update();
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;

    // Bounce off walls
    if (this.x < 0 || this.x + squareSize > window.innerWidth) this.vx *= -1;
    if (this.y < 0 || this.y + squareSize > window.innerHeight) this.vy *= -1;

    this.div.style.left = this.x + 'px';
    this.div.style.top = this.y + 'px';
  }
  
  flash() {
    this.div.style.background = flashColor ? '#fff' : '#000';
  }
  
  remove() {
    if (this.div.parentNode) {
      this.div.parentNode.removeChild(this.div);
    }
  }
}

// Animate all squares
function animateSquares() {
  squares.forEach(sq => sq.update());
  animationId = requestAnimationFrame(animateSquares);
}

// Start flashing effect
function startFlashing() {
  if (flashInterval) clearInterval(flashInterval);
  flashInterval = setInterval(() => {
    flashColor = !flashColor;
    squares.forEach(sq => sq.flash());
  }, 1000);
}

// Start automatic duplication every second
function startAutoDuplication() {
  if (duplicationInterval) clearInterval(duplicationInterval);
  duplicationInterval = setInterval(() => {
    if (squares.length > 0) {
      duplicateSquares();
    }
  }, 1000);
}

// Duplicate squares with small random offsets
function duplicateSquares() {
  const current = [...squares];
  current.forEach(sq => {
    const offsetX = (Math.random() - 0.5) * 60;
    const offsetY = (Math.random() - 0.5) * 60;
    const newSq = new Square(sq.x + offsetX, sq.y + offsetY);
    squares.push(newSq);
  });
}

// Start initial squares
function startSquares() {
  if (squaresStarted) return;
  squaresStarted = true;
  
  // Clear any existing squares
  squares.forEach(sq => sq.remove());
  squares = [];
  
  // Create 100 squares instead of 5
  for (let i = 0; i < 100; i++) {
    squares.push(new Square());
  }
  
  if (!animationId) {
    animateSquares();
  }
  startFlashing();
  startAutoDuplication();
}

// Fullscreen trigger
async function enterFullscreen() {
  try {
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    else if (el.mozRequestFullScreen) await el.mozRequestFullScreen();
    else if (el.msRequestFullscreen) await el.msRequestFullscreen();

    document.body.style.background = '#000';
    const text = document.getElementById('text');
    if (text) text.style.display = 'none';
    startSquares();
  } catch(err) {
    console.log('Fullscreen failed:', err);
    // Fallback if fullscreen fails
    document.body.style.background = '#000';
    const text = document.getElementById('text');
    if (text) text.style.display = 'none';
    startSquares();
  }
}

// Update background when exiting fullscreen but keep everything running
function handleFullscreenExit() {
  document.body.style.background = originalBG;
  const text = document.getElementById('text');
  if (text) text.style.display = 'block';
  // DON'T stop the animation or clear squares - keep everything running
}

// Event handlers
function clickHandler(e) { 
  // Only duplicate if we're already in square mode
  if (squaresStarted) {
    duplicateSquares();
  } else {
    // Otherwise enter fullscreen and start
    enterFullscreen();
  }
}

function keyHandler(e) { 
  if (e.key !== 'Escape' && squaresStarted) {
    duplicateSquares();
  }
}

// Fullscreen change handler
document.addEventListener('fullscreenchange', () => {
  if (!document.fullscreenElement && 
      !document.webkitFullscreenElement && 
      !document.mozFullScreenElement && 
      !document.msFullscreenElement) {
    handleFullscreenExit();
  }
});

// Also listen for specific fullscreen exit events
document.addEventListener('webkitfullscreenchange', () => {
  if (!document.webkitFullscreenElement) {
    handleFullscreenExit();
  }
});

document.addEventListener('mozfullscreenchange', () => {
  if (!document.mozFullScreenElement) {
    handleFullscreenExit();
  }
});

document.addEventListener('MSFullscreenChange', () => {
  if (!document.msFullscreenElement) {
    handleFullscreenExit();
  }
});

// Handle window resize
window.addEventListener('resize', () => {
  squares.forEach(sq => sq.update());
});

// Initial setup - just add the click handler
document.addEventListener('click', clickHandler);
document.addEventListener('keydown', keyHandler);

</script>
</body>
</html>
